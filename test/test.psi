// skipped

def main(){
	return (0,2,3,1)[0..2];
}

/+
def bar(x:â„){
    cobserve(x,1/2); // not ok, in the current block, x is a dirac measure
}


def main(){
	y:=uniform(0,1);
	bar(y); // even though here we call the function with an uniform
	return y;
}

def foo[n:â„•](xs:â„^n):â„^(2Â·n)â‡’xs~xs;
+/
/+
def main(){
	which:=categorical([2^(1/2)*1/4,
		if which==0{
		x7 := uniform(0/1, (2/1)^(1/2) * (1/2));
	}
   weight(real2prob(x7 ^ 2 * (+2/1) + (+1/1)), return x7 < +1/2)) <|>
weight
  (real2prob(+1/1 + prob2real(sqrt(2/1)) * (-1/2)),
   x7 <~ uniform(prob2real(sqrt(2/1)) * (+1/2), +1/1)
   return x7 < +1/2)


def main(){
	x:=gauss(0,1);
	//y:=gauss(0,1);
	return x*x;
}
+/
/+
n:=3;
def main(){
	arr := [1,2,0];
	cmp := array(n,array(n,0:ğ”¹));
	for i in [0..n){
		for j in [0..n){
			cmp[i][j]=arr[i]<arr[j];
		}
	}
}
+/
/+
def main(X){
	(s,b):=(gauss(0,1),gauss(0,1));
	e:=gauss(0,1);
	cobserve(s+b+e,2.5);
	return (s*X+b);
	//r:=sampleFrom("(r;X)=>(-[Xâ‰¤0]Â·â…ŸX+[-Xâ‰¤0]Â·â…ŸX)Â·[Xâ‰ 0]Â·e^((-10Â·rÂ·â…ŸXÂ³-4Â·rÂ²Â·â…ŸXÂ³+15Â·rÂ·â…ŸXÂ²+4Â·rÂ²Â·â…ŸXâ´+rÂ²Â·â…ŸXÂ²)Â·â…Ÿ(-4Â·â…ŸX+4+4Â·â…ŸXÂ²)+-rÂ²Â·â…ŸXÂ²+rÂ·â…ŸX)+[X=0]Â·e^(rÂ²)",X);
}
+/
/+
def main(X,Y){
	x := uniform(0,1);
	y := x^2+uniform(0,1);
	observe(y>Y);
	return x<X;
}
+/
/+
def main(){
	p := uniform(0,1);
	return errorPr(infer((){assert(flip(p));}))==1-p; // expected: Î´(1)[r]
}
+/
/+
def allSprouted(state) => state == 3;
def someSprouted(state) => state > 0;
def noneSprouted(state) => state == 0;

all := 0, some := 1, none := 3;

def meaning(words)â‡’
	if words == none { noneSprouted } else
                     { assert(false);   };

def main(){
	def literal_listener(words)â‡’ infer((){
		wordsMeaning := meaning(words);
		x:=wordsMeaning(0);
	});
	cur_listener := literal_listener;
	return cur_listener;
}
+/


/+
def main(p){
	return geometric(p); // TODO
}
+/
/+
def main(){
	y:=2;
	dat Foo{
		x:â„•;
		def Foo(){
			//this.x=y;
			x=2;
		}
		def bar(){
			return y;
		}
	}
	return Foo().bar();
}
+/
/+
def main(){
	f := ()=>2;
	i := 3;
	if true{
		x := 3;
		f = ()=>x+i;
	}
	return f;
}
+/
/+
def main(){
	x:=infer;
	x=[a]â‡’infer[a];
	x=if flip(1/2){
		infer;
	}else{
		[a]â‡’infer[a];
	}
}
+/
/+
dat X{
	def X(){}
	def foo(k){
		return ();
	}
}

def main(){
	x:=X();
	return x.foo(0);
}
+/
/+
def main(){
	if flip(1/2){
		x:=2;
	}else{
		x:=3;
	}
	return x;
}
+/
/+
def main(){
	(x,y,z):=(0,0,0);
	((x,y),z)=((1,2),3);
	return (x,y,z);
}
+/
/+
def main(){
	x:=true:ğ”¹;
	if x{
		f:=()=>2;
		return f();
	}
	assert(false);
}
+/

/+
def main(){
	x:=gauss(0,1);
	l:=(x^2)^(1/2);
	//return (x/l);
	return (x/l);
}
+/
/+
def main(){
	x:=(gauss(0,1),gauss(0,1));
	l:=(x[0]^2+x[1]^2)^(1/2);
	return (x[0]/l,x[1]/l);
}
+/
/+
def factorial(n){
	if n<=0{ return 1; }
	return sampleFrom("(r;n)â‡’Î´(âˆ«dx[0â‰¤x] x^nÂ·e^-x)[r]",n);
}
+/
/+
def factorial(n){
	r:=1;
	for i in (0..n]{
		r*=i;
	}
	return r;
}
def nCk(n,k){
	return (0<=k)*(k<=n)*factorial(n)/(factorial(k)*factorial(n-k));
}
def main(){
	(n,k,p):=(20,6,1/3);
	x:=binomial(n,p);
	return (Expectation(nCk(x,k)),p^k*nCk(n,k));
}
+/
	
/+
def main(){
	a:=[uniform(0,2),uniformInt(1,3)/3];
	x:=a[flip(1/2)];
	p:=infer((){
		y:=uniform(0,1);
		observe(y<=x);
		return y;
	});
	return sample(p);
}
+/

/+
def main(){
	winter := flip(0.5);
	clouds := if winter then flip(0.8) else flip(0.3);
	base := if winter then 3 else 0;
	altitude := [base + 3, base + 5, 10][uniformInt(0,2)];
	rainfall := if clouds then altitude else 0;

	d:=Marginal(rainfall,clouds);
	return expectation(infer((){ (r,c):=sample(d); observe(c==clouds); return r; }));
}
+/
/+
def main(){
	x := log(abs(gauss(0,1)));
	return x;
}
+/
/+
def main(){
	x := gauss(0,1)^2;
	return x;
}
+/
/+
def main(){
	p := 1/100;
	x := geometric(p);
	return Expectation(x<=1/p);
}
+/
/+
def main(n){
    x := array(n,0);
    x[uniformInt(0,n-1)]=uniform(0,1);
    x[uniformInt(0,n-1)]=2*x[uniformInt(0,n-1)];
    return x[uniformInt(0,n-1)];
}
+/
/+
def main(Z){
	x := gauss(0,1);
	y := gauss(x,1);
	z := gauss(x,1);
	return (y,z);
}
+/
/+
def fib(n:â„):â„{
	if n>1{ return fib(n)+fib(n-2); }
	return n;
}

def main(){ }
+/
/+
def main(){
	return uniform(0,1)^2;
}
+/
/+n:=50;
def main(){
	s := 0;
	for i in [0..n){
		s+=exponential(1);
	}
	return s;
}

/+// skipped
def main(){
	p:=1/1000;
	k:=256;
	repeat k{
		if flip(1/2) && flip(p)==0{ return 0; }
	}
	return 1;
}
+/
+/
/+
def main(Î»,k){
	x := poisson(Î»);
	observe(x+poisson(Î»)==k);
	return x==0;
}
+/
/+
def main(){
	a := array(n,2);
	(a[0],a[1]) := (a[1], a[0]);
}
+/
/+
def foo():ğŸ™{}

def main():ğŸ™{
	//x := foo: ğŸ™â†’ğŸ™;
	def foo(d: Distribution[â„])â‡’sample(d);
	x := foo : Distribution[â„] â†’ â„;
	
	return;
}
+/
/+
def main(n: !â„){
	x := ![1,2,3];
}
+/
/+
def main(){
	i := 2;
	if 1{
		i := 3;
	}
	for _ in [0..10){
		for _ in [0..10){
			return _;
		}
	}
}
+/

/+
// justifying manipulations in DP-finder

def lebesgue(){ // not really supported.
	return sampleFrom("(x)=>x/x");
}
def progA(y,Î½){
	X := lebesgue(); // uniform prior on X
	Y := gauss(X,Î½); // Y is sampled depending on X
	cobserve(Y,y);   // Y is observed to be y (the estimate)
	return X;        // posterior on X
}
def progB(y,Î½){
	return gauss(y,Î½);
}

def main(y,Î½){
	return progA(y,Î½); // expected: [Î½=0]Â·Î´(0)[-y+r]+[Î½â‰ 0]Â·e^((-1/2Â·rÂ²+-1/2Â·yÂ²+rÂ·y)Â·â…ŸÎ½)Â·â…ŸâˆšÌ…2Â·â…ŸâˆšÌ…Î½Â·â…ŸâˆšÌ…Ï€
	//return progB(y,Î½); // expected: [Î½=0]Â·Î´(0)[-y+r]+[Î½â‰ 0]Â·e^((-1/2Â·rÂ²+-1/2Â·yÂ²+rÂ·y)Â·â…ŸÎ½)Â·â…ŸâˆšÌ…2Â·â…ŸâˆšÌ…Î½Â·â…ŸâˆšÌ…Ï€
}
+/

/+
def main(){
	x := poisson(1/2);
	y := poisson(1/2);
	return x==y;
}
+/
/+
def main(){ // TODO: make work (other integration order works already)
	x := geometric(1/2);
	y := geometric(1/2);
	return 2*x==y; // expected: 2/7Â·Î´(1)[r]+5/7Â·Î´(0)[r]
}
+/
/+ // TODO: make work (with and without observe)
def main(){
	x := geometric(1/2);
	//observe(x<=10);
	return x%2!=0;
}
+/
/+
def test(n){
	x := uniformInt(0,n-1);
	return x^3+x^2+x+1!=0;
}
def main(){
	return test(10);
}
+/
/+
def main(){
	return uniform(0,1)^2+uniform(0,1);
}
+/
/+
def main(z){
	//z := uniform(0,1);
	x := infer((){
		y := uniform(0,1);
		observe(y <= z);
		return y;
	});
	return expectation(x);
}
+/
/+
def main(){
	y := uniform(0,1);
	f := (x)=>x;
	if flip(1/2){
		f = (x)=>x+5;
	}
	return f(y^2);
}
+/

/+
def main(){
	Î¼ := [0,0];
	Î£ := [[1,3/5],[3/5,2]];
	return multiGauss(Î¼,Î£);
}
+/

/+
dat Foo[a]{
	x: Foo[Foo[a]][];
	def Foo(){
		x = []: Foo[Foo[a]][];
	}
}

def main(){
	f := Foo[â„]();
	f.x[0].x[0]=2;
}
+/
/+
def main(){
	p := uniform(0,1);
	for i in [0..5){
		observe(flip(p));
	}
	//return flip(p);
	return p;
}
+/
/+def main(){
	x := 1;
	y := 1;
	z := x-y;
	z = 1.0;
	return z;
}
+/
/+
def main(){
	randArr := array(5,0);
	for i in [0..5){
		pos := uniformInt(0,4);
		randArr[pos] = i;
	}
	return randArr[0];
}
+/
/+
def main(c){
	assert(0<=c&&c<=10);
	x := uniform(0,10);
	y := 0.0;
	if (x > c) { y = x + 1; } else { y = 10; }
	return y;
}
+/
/+def main(x){
	return ~x;
}
+/
/+
def main(){
	return laplace(20);
}
+/
/+
def main(y){
	x := 2121*y;
	x = x^(1/2);
	return x;
}
+/
/+
def main(){
	n := 9;
	x := binomial(n, 1/2);
	y := n-x;
	//Expectation(x*y) = Expectation((x-n/2)*(y-n/2)) + n/2Â·Expectation(x+y)-n^2/4.
	//return Expectation(x*y);
	//return n^2/4-Expectation((x-n/2)*(x-n/2));
	//return (n^2-n)/4
	// 0 â‰¤ Variance(X+Y)
	//   = Expectation((X+Y)^2) - Expectation(X+Y)^2
	//   = 2Â·Expectation(X^2)+2Â·Expectation(XÂ·Y) - 4Â·Expectation(X)^2
	// â‡’ Expectation(XÂ·Y)â‰¥2Â·Expectation(X)^2-Expectation(X^2).
	// â‡’ Expectation(XÂ·Y)â‰¥2Â·Expectation(X)^2-Expectation(X^2).
}
+/
/+
def main(){
	x := geometric(1/2);
	return Expectation(x^2);
}
+/
/+
def main(){
	x := 2^(1/2);
	return x<=1;
}
+/
/+def main(){
	x := uniform(0,1);
	y := uniform(0,1);
	observe(x*y<0.2);
	return x+y;
}
+/
/+
def main(){
	return â„ Ã— â„;
}
+/
/+
def main(x){
	repeat 1{
		return 2;
	}
}
+/
/+
def main(){
	qâ‚ := 2663191003150725233/5997013881313296384;
	return qâ‚;
}
+/

/+
def main(r){
	x := geometric(1/2);
	y := geometric(1/2);
	return Expectation(x+y<=r);
}
+/

/+
def main(p){
	x := geometric(1/2);
	return Expectation(x^2)-Expectation(x)^2;
	//return Expectation(x);
}
+/
/+
def main(){
	x := geometric(1/2);
	assert(x!=10);
	return ();
}
+/	

/+
def main(){
	x := gauss(0,1);
	return Expectation(x^12);
}
+/
/+
def main(){
	x := gauss(0,1);
	return Expectation(x^6);
}
+/
/+
def main(){
	x := uniform(0,1);
	return Expectation(x);
}
+/
/+
def main(){
	for i in [0..n){
		
	}
}
+/

/+def lipschitz(L: â„)(f: â„â†’â„)
    â‡’ âˆ€(x:â„,y:â„). abs(f(x)-f(y))<=L*abs(x-y);+/

//def Lipschitz(L: â„) := {f: â„ â†’ â„ | lipschitz(L)(f) };
/+
def main(){
	x := 1;
	x = 2;
	y := 2;
	if x = y {
		return 2;
	}
	return 3;
}
+/
/+
def main(){
	def roll()â‡’ uniformInt(1,6);
	//return (roll()+roll()+roll()==12)*6^3;
	x := roll()+roll();
	return x<6;
}
+/
/+
n := 2;

def matmul[n,m](m: â„^(nÃ—m), x: â„^m){
	r := array(n,0);
	for i in [0..n){
		for j in [0..n){
			r[i] += m[i][j]*x[j];
		}
	}
	return r;
}

def main(){
	//m := [1 for i in iota(1,2)];
	m := [[1, 1], [1, 0]];
	x := [1, 0];
	//return matmul(m,matmul(m,matmul(m,matmul(m,x))))[0];
	return (x:â„[])=>matmul(m,matmul(m,matmul(m,matmul(m,x))));
}
+/
/+
def main(){
	x := uniform(-1, 1);
	y := uniform(-1, 1);
	return x-y;
}
+/
/+
def main(q){
	return geometric(q);
}
+/
/+
def main(){
	return Expectation(geometric(1/2)^2); // TODO
}
+/
/+
def main(){
	return Expectation(geometric(1/2)); // TODO
}
+/
/+
def main(){
	x := geometric(1/2);
	y := geometric(1/2);
	return x+1==y; // TODO
}
+/
/+
def main(){
	x := geometric(1/2);
	y := geometric(1/2);
	return x==y;
}
+/
/+
def main(){
	x := geometric(1/2);
	return x > 100; // TODO
}
+/
/+
def main(){
	return uniformInt(0,100000)<=1;
}
+/
/+
def main(){
    a := [1,1,1];
    x := categorical(a);
    return x;
}
+/
/+
def main(){
	n := 10;
	//return 2^floor(log(n)/log(2)+1); // TODO: evaluate
	x := 0;
	for i in [0..10){
		x = x âŠ• uniformInt(0,n-1);
	}
	return x;
}
+/
/+
def main(){
	x := uniformInt(0,2);
	return x;
}
+/
/+
def variance(d: Distribution[â„]){
	return Expectation(sample(d)^2)-Expectation(sample(d))^2;
}

def main()â‡’variance(infer((){
	//x := uniform(0,1);
	//y := uniform(0,1);
	//y := x;
	//a := 1+x;
	//b := (1-y)^2;
	a := gauss(0,1);
	b := gauss(0,1);
	return log(a)-log(b);
}));
+/

//def mux[a](x: â„, y: a, z: a)â‡’ if x then (y,z) else (z,y);

/+
def main(){
	return binomial(3,uniformInt(1,4));
}
+/

/+
def main(){
	x := geometric(1/2);
	y := geometric(1/2);
	return x==y;
}
+/
/+
def main(){
	v := array(5,0);
	k := 7;
	for i in [0..k){
		v[uniformInt(0,4)]=1;
	}
	def all(a:â„[]):â„â‡’ if a.length==0 then true else a[0]&&all(a[1..a.length]);
	return (all(v),(5^k-5*4^k+10*3^k-10*2^k+5)/5^k);
}
+/

/+
n := 2;

def mmv(A: â„[][], b: â„[]){ // matrix-vector product
	return sampleFrom("(r;A,b)=>Î´([iâ†¦ âˆ‘_j[0â‰¤j]Â·[j<b.length] A@[i]@[j]Â·b@[j]] (A.length))[r]",A,b):â„[]; // performance hack
}

def avv(a: â„[], b: â„[]){ // vector addition
	return sampleFrom("(r;a,b)=>Î´([iâ†¦ a@[i]+b@[i]] (a.length))[r]",a,b):â„[]; // performance hack
}

def dot(a: â„[], b: â„[]){ // dot product for first m entries of vector
	return sampleFrom("(r;a,b)=>Î´(0)[-r+âˆ‘_i[0â‰¤i]Â·[i<a.length] a@[i]Â·b@[i]]",a,b); // performance hack
}

def cholesky(A: â„[][]){ // cholesky decomposition
	assert(sampleFrom("(r;A)=>Î´([âˆ‘_i[0â‰¤i]Â·[i<A.length]âˆ‘_j[0â‰¤j]Â·[j<A.length]Â·[A@[i]@[j]â‰ A@[j]@[i]]=0])[r]",A));
	L := array(A.length,array(A.length,0));
	for i in [0..n){
		if i < A.length {
			for j in [0..i+1){
				if j < A.length{
					t := dot(L[i][0..j],L[j][0..j]);
					if i == j {
						assert(A[i][j]>=t);
						L[i][j] = (A[i][j]-t)^(1/2)
					}else if L[j][j]!=0{
						L[i][j] = (A[i][j]-t)/L[j][j];
					};
				}
			}
		}
	}
	return L;
}

def multiGauss(Î¼: â„[], Î£: â„[][]){
	r := array(n,0);
	for i in [0..n){
		r[i] = gauss(0,1);
	}
	return avv(mmv(cholesky(Î£),r),Î¼);
}
/+
def main(){
	Î³ := 2/5;
	Î£ := [[1,Î³],[Î³,1]];
	r := multiGauss([0,0],Î£);
	(x,y) := (r[0],r[1]);
	return (x,y);
}
+/


def main(){
	/+Î³ := 2/5;
	Î£ := [[1,Î³],[Î³,1]];
	r := multiGauss([0,0],Î£);
	(x,y) := (r[0],r[1]);
	/*Î¼â‚ := 10;
	Î¼â‚‚ := 2;
	x := gauss(Î¼â‚,1);
	y := gauss(Î¼â‚‚,1);*/
	return (x,y);+/
	(x,y) := sampleFrom("(x,y)=>5/2Â·e^(-25/42Â·xÂ²+-25/42Â·yÂ²+10/21Â·xÂ·y)Â·â…ŸÏ€Â·â…Ÿâˆš2Ì…1Ì…");
	return (x/y);
}
+/

/+
def main(y){
	x := uniform(-1,1);
	cobserve((0<=x)*(x<=1)*x+(1<x),0);
	return x;
}
+/
/+
def main(){
	x := gauss(0,1);
	y := expectation(infer(()=>gauss(0,1)<=x));
	return y;
}
+/
/+
def main(){
	x := uniform(-1,1);
	return log(x);
}
+/
/+
def main(){ // TODO: make fast
	epsilon := 0.1;
	delta := 1;
	T := 0;

	c := 1;
	input:=[1.0,2.0,3.0,4.0];
	output:=array(4,0);

	epsilon1 := epsilon/2;
	rho := laplace(0, delta/epsilon1);
	epsilon2 := epsilon - epsilon1;

	count := 0;
	for i in [0..input.length) {
		vi := laplace(0, c*delta/epsilon2);
		if input[i]+vi>=T+rho{
			output[i]=input[i]+vi;
		}else{
			output[i]=-10000;
		}
	}
	return (output[0],output[1],output[2],output[3]);
}
+/
/+
def main(){
	x := gauss(0,1);
	y := gauss(0,1);
	return max(x,y);
}
+/
/+
def main(){
	x := uniform(-1,1);
	y := uniform(-1,1);
	z := uniform(-1,1);
	cobserve((y^2+z^2)^(1/2),(1-x^2)^(1/2));
	return (x,y,z);
}
+/
/+
def main(){
	x := uniform(-1,1);
	y := uniform(-1,1);
	z := uniform(-1,1);
	cobserve(x^2+y^2+z^2,1);
	return (x,y,z);
}
+/
/+
def main(Î´){
	Îµ := 1/Î´;
	x := uniform(0,1);
	y := uniform(0,1);
	//observe(abs(x/y-1)<=1);
	observe(abs(x-y)<=Îµ);
	return x;
}
+/
/+
def main(Î´){
	Îµ := 1/Î´;
	x := uniform(0,1);
	y := uniform(0,1);
	observe(abs(x-y)<=Îµ);
	//cobserve(x/y,1);
	return x;
}
+/
/+def main(Î´){
	Îµ := 1/Î´;
	x := uniform(0,1);
	y := uniform(0,1);
	observe(abs(x/y-1)<=Îµ);
	//cobserve(x/y,1);
	return x;
}
+/

/+
def main(){
	return beta(2,2);
}
+/
/+
def main(){
    p := uniform(0,1);
    xâ‚ := flip(p);
    xâ‚‚ := flip(p);
    observe(xâ‚ && !xâ‚‚);
    return p
}
+/

/+
def main(){
    x := uniform(0,1);
    y := (2+x)/(3+x);
    return y;
}
+/

/+
def main(){
    x := if flip(1/2)
         then uniform(0,1)
         else 1/2;
    return x*(1-x);
}
+/
/+
def main(){
	x := 1;
	i := 0;
	while(x){
		x := flip(1/2);
		i += 1;
	}
	return i;
}
+/
/+
def main(){
	/*x := uniform(0,1);
	y := uniform(0,1);
	observe(x+y<=9/10);
	return x*y<=1/10;*/
	x := gauss(0,1);
	y := gauss(0,1);
	observe(y >= -1/2);
	x = min(x, y);
	return x;
}
+/
/+
def main(){
	a := [[0,1],[1,2]];
	a[flip(1/2)][0] = 3;
	return a[0][0];
}
+/
/+
def main(){
	x := if flip(1/2)||1
	     then uniform(0,1)
	     else 1/2;
	return x*(1-x);
}
+/
/+
def main(Î´){
	Îµ := 1/Î´;
	x := uniform(0,1);
	y := uniform(0,1);
	//observe(abs(x-y)<=Îµ);
	observe(abs(x/y-1)<=Îµ);
	return x;
}
+/

/+def main(){
    x := uniform(0,1);
    y := uniform(0,1);
    cobserve(x-y,0);
    return x;
}
+/
/+def main(){
    x := uniform(0,1);
    y := uniform(0,1);
    cobserve(x/y,1);
    return x;
}
+/

/+

def main(){
	x := gauss(0,1);
	//x = min(x, exponential(1));
	//x = min(x, exponential(1));
	//x = min(x, exponential(1));
	x = max(x, uniform(0,1));
	x = max(x, uniform(0,1));
	if x < 2{
		x += 3;
	}
	return x;
}
+/
/+
def formula(x: â„[])=>x[1] && (x[2] || !x[1]) && (x[1] || x[0] || !x[2]);

def main(){
	n := 3;
	x := array(n,0);
	for i in [0..n){
		x[i] = flip(1/2);
	}
	observe(formula(x));
	//return 2^n*formula(x);
	return ((x[0],x[1],x[2]),);
}
+/
/+
def main(){
	k := 2;
	n := 4;
	centers := array(k,0);
	for i in [0..k){
		centers[i] = gauss(0,20^2);
	}
	//data := array(n,0);
	(realCenters, observedData) := ([8.4e+00,2.7e+01],[2.8e+01,9.8e+00,8.5e+00,2.6e+01]);
	for i in [0..n){
		c := uniformInt(0,k-1);
		//data[i] = gauss(centers[c],1);
		cobserve(gauss(centers[c],1),observedData[i]);
	}
	
	/*for i in [0..n){
		cobserve(data[i],observedData[i]);
	}
	return (centers[0],centers[1]);*/
	return (centers[0],centers[1]);
	//return (min(centers[0],centers[1]), max(centers[0],centers[1]));
}
+/
/+
def main(){
	p := uniform(0,1);
	def experiment(x){
		observe(flip(p)==x);
	}
	experiment(1);
	experiment(0);
	experiment(0);
	/*experiment(1);
	experiment(1);
	experiment(1);
	experiment(1);*/
	return p;
}
+/

/+ // nice example for floating-point inaccuracy
def main(a){
	x := uniform(0,10);
	cobserve(x + gauss(0,1), a-0.5);
	cobserve(x + gauss(0,1), a-0.5);
	return x;
}
+/
/+
def main () {
	x := uniform (0 ,10) ; // unknown location
	// noisy measurements :
	cobserve (x + gauss(0,1), 5.232) ;
	cobserve (x + gauss(0,1), 6.112) ;
	return x;
	// what do we know about the location now ?
}
+/

/+
def main(){
	x := if flip(1/2)
	     then uniform(-1/2,1)
	     else 0;
	y := x^2;
	return y;
}
+/
/+
def main(){
	return gauss(0,1);
}
+/
/+
def main(){
	p := 1/2;
	timon_lied := flip(1e-20); // very honest
	if timon_lied{
		p = uniform(0,1);
	}
	for i in [0..100){
		observe(flip(p)==1); // all heads
	}
	return p; // probability of next head
}
+/

/+
def main(k){
	x := uniform(0,1);
	y := 1-x;
	z := 2*x+y;
	cobserve(z,1);
	return x;
}
+/

/+
def main(){
	(a,b) := (gauss(0,1),gauss(0,1));
	x := a*5+b*10;
	y := a*3+b*3;
	return (x-y)^2;
}
+/
/+
def main(){
	r := multiGauss([0,0],[[1,0],[0,1]]);
	return (r[0],r[1]);
}
+/
/+
def main(){
	yâ‚ := uniform(-1000,1000);
	yâ‚‚ := uniform(-1000,1000);
	observe((1 <= -1/5*yâ‚ + 1/10*yâ‚‚) && (-1/5*yâ‚ + 1/10*yâ‚‚ <= 3) && (4 <= 3/20*yâ‚ -1/20*yâ‚‚) && (3/20*yâ‚ -1/20*yâ‚‚ <= 8));
	return (yâ‚,yâ‚‚);
}
+/

/+
def main () {
	ret:=1;
	
	mult1:=0;
	if ?o1{
		mult1=exp(?a1);
	}else{
		mult1=1-exp(?a1);
	}
	ret*=mult1;
	
	mult2:=0;
	if ?o2{
		mult2=exp(?a2);
	}else{
		mult2=1-exp(?a2);
	}
	ret*=mult2;

	return ret;
}
+/
/+
def main(a:â„[]){
	x := 1;
	for i in [0..10){
		x*=(1+a[i]);
	}
	return x;
}
+/

/+
def main(){
	x := sampleFrom("(x)=>delta(1,2)[x]"): â„ x â„;
	return x[1];
}
+/
/+
def main(){
	return 1/gamma(3,3);
}
+/
/+
def main(x,Î²){
	y := gauss(x,Î²);
	if y > 0 { } else { y = 0; }
	return y;
}
+/

/+
def main(){
	x := gauss(0,1);
	return Expectation(x^2)-Expectation(x)^2;
}
+/
/+
def main(){
	//return -log(uniform(0,1))/2;
	return exponential(0.1);
}
+/
/+
def main(){
	//return log(uniform(0,1));
	return -exponential(1);
}
+/
/+
def main(x){
	a := x>0;
	b := x>0;
	return a/b;
}
+/
/+
def main(){
	r := multiGauss([0,0],[[1,1],[1,1]]);
	return (r[0],r[1]);
}
+/
/+
def main(){
	r := dirichlet([1,1]);
	return (r[0],r[1]);
}
+/
/+
def main(beta,delta){ // TODO: make this fast
	diff := exponential(beta)-exponential(beta);
	return -delta/2<=diff && diff<=delta/2;
}
+/

/+
def foo(x){
	return expectation(infer((){
		a := gauss(0,1);
		b := gauss(0,1);
		return
		if a <= x & x <= b
	      then 1
	      else -1;
	}));
}

def main(x){
	return foo(x);
}
+/

/+
def main(x,y){
	return if flip(1/2) then x==y else y;
}+/


/+def main(x,y){
	Î½ := exponential(1);
	assert(Î½!=0);
	Î¸ := gauss(0,100);
	Î¸â‚ := gauss(Î¸,Î½);
	Î¸â‚‚ := gauss(Î¸,Î½);
	cobserve(Î¸â‚,x);
	cobserve(Î¸â‚‚,y);
	/+cobserve(Î¸â‚,4);
    cobserve(Î¸â‚‚,5);+/
	return (Î¸,Î½);
}
+/

/+import genCap;

def informationFlow[a,b](input: Distribution[a], channel: aâ†’ b,eqa: aÃ—aâ†’â„,eqb: bÃ—bâ†’â„)â‡’
I(infer((){
	i := sample(input);
	o := channel(i);
	return (i,o);
}),eqa,eqb);

def bsc(q)â‡’(b)â‡’bâŠ•flip(q);

def main(p,q){
	input := infer(()â‡’ flip(p));
	channel := bsc(q);
	return informationFlow(input, channel, eqâ„,eqâ„);
}
+/

/+ // TODO
def approxGauss(Î¼,Î½){
	return sampleFrom("(x;Î¼,Î½)=>",Î¼,Î½);
}

def main(){
	
}
+/
/+
dat Filter{
	x: â„, v: â„, a: â„;
	def Filter(x: â„, v: â„, a: â„)
	{ (this.x,this.v,this.a) = (x,v,a); }
	def update(t: â„)
	{ (x,v,a) = (x+t*v,v+t*a,a+t*gauss(0,1)); }
	def measureX(x: â„, t: â„)
	{ cobserve(this.x+t*gauss(0,1),x); }
}
def main(){
	data := [1,3,6,10,15,20,25,30,35,40];
	filter := Filter(gauss(0,0.1),2,1);
	results := []:Distribution[â„][];
	for i in [0..data.length){
		filter.update(1);
		filter.measureX(data[i],1);
		results ~= [Marginal(filter.x)];
	}
	return sample(results[4]);
}
+/
/+
def main(){
	(aa,ab) := (flip(0.9),flip(0.9));

	(ba,bb) := (flip(0.9),flip(0.9));
	
	(ca,cb) := (if flip(1/2) then aa else ab,if flip(1/2) then ba else bb);
	if flip(1/2){
		tmp := ca;
		ca = cb;
		cb = tmp;
	}
	observe(aa==0&&ab==1);
	observe(ca==0&&cb==1);
	/*if flip(1/2){
		observe(ba==0||bb==0);
	}else{
		observe(ba==1||bb==1);
	}*/
	return (ba,bb);
}+/

/+
def main(){
	x := uniform(0,1);
	//assert(x!=1/2);
	cobserve(x,1/2);
}
+/
/+
// 1-(b/x)^a

// y=1-(b/x)^a
// 1-y=(b/x)^a
// (1-y)^(1/a) = b/x
// x=b/(1-y)^(1/a)
+/
/+
def main(){
	n := 2;
	x := array(n,0);
	for i in [0..n){
		
	}
}
+/
/+
def main(){
	//return (x);
	//return pareto(10,10);
	//return rayleigh(10);
	//return uniform(0,1)<=x;
	//return uniform(200,201);
	x := 3;
	y := 4;
	def f(){
		return x+y;
	}
	k := f();
	//return x+y;
	return flip(1/2);
	//return [1,2,3][2];
	//return f;
}
+/
/+
def main(){
	return gauss(0,1)^2;
	//return exp(1.2);
	//p := uniform(0,1);
	//return p+flip(1/2) <= x;
}
+/
/+def main(k){
    x := laplace(0, 100);
    return floor(x)<=k;
}+/
/+
def main(x){
	//x := (x)=>2*x;
	//return x(flip(1/2))<=k;
	if x < 100 { return if flip(1/2) then 1 else x; }
	return flip(1/3);
}
+/
/+
def min(a,b)=> if a < b then a else b;

def main(x){
	observe(0);
	a := [1,2,3];
	r := 10000;
	for i in [0..3){
		r = min(r, a[i]+laplace(0,1));
	}
	return r<=x;
}
+/
/+
def main(x){
	//return exponential(1);
	//return (2*flip(1/2)-1)*log(uniform(0,1));
	//return exponential(1);
	//return laplace(0,10)<=x;
	//return gauss(0,1)<=x;
	//return (1,x);
}
+/
/+def main(){
	return uniform(0,1);
}+/

/*def main(x){
	y := 0;
	//y = categorical([1/3,1/6,1/2]);
	return uniformInt(0,1);
	//return y;
}*/

/+
def main(x){
	y := -1;
	if x < 0 {
		y=1;
	}else{
		y=2;
	}
	x := flip(1/2);
}
+/
/+def main(a: â„[]){
	r := 0;
	for i in [0..2){
		if flip(1/2){
			r+=a[i];
		}
		if r>1{ return 1; }
	}
	return r;
}+/

/+def main(){
	//return laplace(0,1);
}+/

/+def main(x,y){
	if x+flip(1/2){
		return x;
	}else{
		return y;
	}
}+/

/+
def main(x){
	//return uniform(0,1);
	return x;
}
+/
/+
def main(){
    y := uniform(0,1);
	x := sample(infer((){
        x := uniform(0,1)+y;
		observe(x<1/2);
		return x;
    }));
    //x := sampleFrom("(x;y) => ([-1/2+-yâ‰ 0]Â·[-1/2+-yâ‰¤0]Â·â…Ÿ(-y+1/2)+[1/2+yâ‰¤0])Â·[-1+-y+xâ‰¤0]Â·[-1/2+xâ‰¤0]Â·[-1/2+yâ‰¤0]Â·[-x+1/2â‰ 0]Â·[-x+yâ‰¤0]Â·[-y+1/2â‰ 0]",y);
    return x<1/3;
}
+/

/+def main(y){
    x := uniform(0,1)+y;
    observe(x<1/2);
    return x;
}+/

/+
def main(){
	x := uniform(0,1);
	y := x^2+uniform(0,1);
	return (x,y);
}
+/
/+
def PrAgivenB[a](d: Distribution[a], A: aâ†’â„, B: aâ†’ â„){
	return expectation(infer((){
		x := sample(d);
		observe(B(x));
		return A(x)!=0;
	}));
}

def main(X,Y){
	joint := infer();
	return PrAgivenB(joint,(x,y)=>x<X/+0.5+/,(x,y)=>y>Y);
}
+/

/+ TODO: simplify this well (the second and third shuffles should not do anything)
def shuffle(a: â„[]){
	b := a;
	for i in [0..3){
		j := uniformInt(i,b.length-1);
		t := b[j];
		b[j] = b[i];
		b[i] = t;
	}
	return b;
}

def main(x:â„[]){
	// a := [1,2,3];
	a := x;
	a=shuffle(a);
	a=shuffle(a);
	a=shuffle(a);
	return a;
}
+/
/+
def k(x){
	if -gauss(0,1)<=x && x<=gauss(0,1) { return -10; } // TODO: -gauss -> gauss changes result
	else { return 10; }
}

def main(x){
	return Expectation(k(x));
}
+/

/+ // TODO
def k(x){
	eps := abs(gauss(0,1));
	if -eps<=x && x<=eps { return -10; }
	else { return 10; }
}

def main(x){
	return Expectation(k(x+gauss(0,1)));
}
+/
/+
def main(){
	x := uniform(0,1);
	y := x;
	if x < 1/2{
		return y;
	}else{
		return uniform(0,1);
	}
	//return x+y;
}
+/
/+
def foo(x) â‡’ 2*x;

def main(){
	x := 3;
	if x != 2 {
		x = 4;
	}
	f := (z) â‡’ 2*z;
	g := (z){
		return 2*z;
	};

	if (z){ return 2*z; }(2){ return 2*x; }
	
	return f(x);
}
+/
/+
def main(){
	return gauss(0,1);
}
+/
/+import genCap;

def main(pâ‚,pâ‚‚){
	//return H(Flip(p),eqâ„);
	return I(infer((){
		x := flip(1/2);
		y := xâŠ• flip(if x then pâ‚ else pâ‚‚);
		return (x,y);
	}),eqâ„,eqâ„)*log(2);
}
+/
/+
def main(){
	x:=uniform(0,1);
	y:=uniform(0,1);
	z:=x/y;
	//observe(z<=1);
	return z;
}
+/
/+def main(){
	x:=uniformInt(1,2);
	y:=uniformInt(0,x-1)+1;
	return y;
}
+/
/+
def sqrt(x)=>x^(1/2);

def gaussPDF(Î¼,Î½)(x){
	return 1/(sqrt(2*Ï€)*Î½)*exp(-(x-Î¼)^2/(2*Î½));
}

def main(){
	Î¼ := 0;
	Î½ := 1;
	pdf := gaussPDF(Î¼,Î½);
	x := gauss(Î¼,Î½);
	return pdf(x)<=1;
}
+/
/+
def min(a,b)=>if a>b then b else a;
def main(){
	n := 8;
	m := n;
	bound := 3;
	state := 0;
	for i in [0..m){
		state = min(bound+1, state+flip(1/n));
	}
	return state;
}
+/
/+
def main(){
	x := uniform(0,1);
	y := uniform(0,1);
	z := uniform(0,1);
	w := uniform(0,1);
	cobserve(x+y+z+w,1);
	return x;
}
// p[x] = âˆáµ¢(âˆ‘â±¼Î´â±¼[xáµ¢]).
// p[xâ‚€=k|âˆ‘áµ¢xáµ¢=1] = p[xâ‚€=kâˆ§ âˆ‘áµ¢xáµ¢=m]/p[âˆ‘áµ¢xáµ¢=m]
+/
/+
dat F{
	a:â„,b:â„;
	def F(a,b){ (this.a,this.b)=(a,b); }
	def eval(x){ return a*x+b; }
}

def main(g0: F,g1: F,g2: F){
	x:=0;
	if g0.b!=g1.b{
		x=-(g0.a-g1.a)/(g0.b-g1.b);
	}
	y := g0.a*x+g0.b;
	return y<g2.a*x+g2.b;
}
+/
/+def main(){
	// x := 0 && ():â„ { assert(0); }();
	def fail():â„{ assert(0); }
	x := 0 && fail();
}
+/
/+
def main(){
    w := flip(1/2) || flip(1/2);	
}
+/
/+def main(){
	return flip(1/2)&&flip(1/2);
}+/

/+
def main(){
	(a,b,c,d,e,f,g) := (flip(1/2),flip(1/2),flip(1/2),flip(1/2),flip(1/2),flip(1/2),flip(1/2));
	//return a || (b || (c || (d || (e || (f || g)))));
	return a || b || c || d || e || f || g;
}
+/
/+
def fib(n:â„):â„ â‡’ if n<=1 then n
                         else fib(n-1)+fib(n-2);

def main(){
	return fib(10);
}
+/
/+
def fib(n: â„): â„{
	if n>1 { return fib(n-1) + fib(n-2); }
	if n<=0 { return 0; }
	return n;
}

def main(){
	return fib(10);
}

def loop():â„â‡’ loop();
+/
/+
def fib(n: â„){
	if n<=0 { return 0; }
	if n<=1 { return n; }
	return fib(n-1) + fib(n-2);
}

def main(){
	return fib(10);
}
+/
/+
def then[a,b](f: aâ†’ b)(d: Distribution[a])=>infer(()=>f(sample(d)));

def variance(x:Distribution[â„]){
    // return expectation(then((x)=>x^2)(x))-expectation(x)^2;
	// return Expectation(sample(x)^2)-Expectation(sample(x))^2;
}

def main(){
	d := Gauss(3,36);
	//return (expectation(d),variance(d));
	return Expectation(sample(d)^2);
}
+/

/+
def id[b](x:b)â‡’x;

def main(){
	f := id: Î [a:*]. aâ†’ a;
	g := id: Pi[a:*]. aâ†’ a;
	h := id: Î [a:*](x:a). a;
	i := id: Pi[a:*](x:a). a;
	j := (([a:*,b:*]=>id[aÃ—b]): Î [c:*,d:*](x:c,y:d). cÃ—d): Î [a:(*Ã—*)](x:a[0],y:a[1]). a[0]Ã—a[1];
	k := ([a:*,b:*]=>id[aÃ—b]): Pi[c:*,d:*](x:c,y:d). cÃ—d;
	l := f[Î [a:*]. a];
	def crash[a:*]: a{ assert(0); }
	// return f(g(h(i(j(k(l(crash),0),1))))); // expected: Î´(1)[râ‚‚]Â·Î´(Î»Î¾â‚. Î›Î¾â‚‚. Î´(âŠ¥)[Î¾â‚‚],0)[râ‚]
	return l(crash); // expected: Î´(Î»Î¾â‚. Î›Î¾â‚‚. Î´(âŠ¥)[Î¾â‚‚])[r]
}
+/

/+
def Cell(){
	def Cell(){}
}

def main(){
	c := Cell();
	x := 1;
	y := 2;
	return (x,y);
}
+/

/+
dat HMM{
    def HMM(){}
    def predict(){ return flip(0); }
}

def main(){
	h := HMM();
    h.predict();
}
+/

/+dat Cell{
    x : â„;
    def Cell(x : â„){
        this.x = x;
    }
    def inc(i){
        x = x + i;
    }
}

def inc(c: Cell, i){
	d := c;
	d.x = d.x + i;
	return d;
}

def main(){
    a := [Cell(0)];
    a[0].inc(1);
    return a[0];
}
+/
/+
def mains(x){
	a := 1, b := 4;
	x := sampleFrom("(x;a,b)=>(âˆ‘_i[aâ‰¤i]Â·[iâ‰¤b]Â·Î´(0)[i-x])Â·â…Ÿ(âˆ‘_i[aâ‰¤i]Â·[iâ‰¤b])",a,b):â„;
	return (x,x); // TODO: better return value naming
}+/
/+
def main(){
	x := array(3);
	x[0] = 3;
	x[2] = 10;
	y := x;
	return y[uniformInt(0,3)];
	//l := 2;
	//return y[l];
}
+/
/+
dat D{
	x:â„;
	def D(){ x=3; }
}

def main(x){
	(x,y,z) := (1,2,3);
	return (x,D().x,y,z,3);
}
+/
/+
def main(x:â„Ã—â„){
	return pareto(3,1)-1;
}
+/
/+
def main(){
	return laplace(0,1)^2;
}
+/
/+
def main(){
	return (4)%abs(-(3/4));
}
+/

/+
def main(){
	a := array(10);
	return (1,a);
}
+/
/+
def main(){
    p := uniform(0,1);
    x1 := flip(p);
    observe(x1==1);
    x2 := flip(p);
    observe(x2==0);
    x3 := flip(p);
    observe(x3==1);
    return p;
}
+/
/+
def main(){
    a := gauss(0,1);
    b := gauss(0,1);
    return if a > b { a } else { b };
}
+/
/+
def main(){
	x := uniform(0,1);
	return x^(1/2);
}
+/
/+
def main(){
	(x,y) := (1,2);
	(x,y) = (y,x);
	return (x,y);
}
+/
/+
dat S{
	children: S[];
	def S(){ this.children = []:S[]; }
}

def main(){
	a := S();
	b := S();
	a.children~=[b];
	b.children~=[a];
	return b;
}
+/
/+
def mains(){
	//return uniformInt(0,9);
	x := uniform(0,1);
	y := uniform(0,1);
	z := uniform(0,1);
	w := uniform(0,1);
	return x*y+z*w;
}
+/
/+
def add(x:â„){
	def foo(y:â„)=>x+y;
	return foo;
}
def main(x){
	return add(2)(3);
}
+/
/+
dat Foo{
	dat Bar{
		def Bar(){}
		def foo(){
			return b;
		}
	}
	b: Bar;
	def Foo(){
		b = Bar();
	}
	def bar(){
		b=Bar();
	}
}

def main(){
	return Foo().b.foo();
}
+/
/+
def main(){
	x := uniformInt(0,10);
	if x>=9{ return -1; }
	return x;
}
+/
/+
def main(a){
	x := uniform(0,1);
	y := a*x+1;
	return y; // expected: ((-[aâ‰¤0]Â·a+[-aâ‰¤0]Â·a)Â·([(-1+-â…Ÿa)Â·a+1â‰¤0]Â·[-â…Ÿaâ‰¤0]Â·â…Ÿ((1+â…Ÿa)Â·a+-1)+[(1+â…Ÿa)Â·a+-1â‰¤0]Â·[â…Ÿaâ‰¤0]Â·â…Ÿ((-1+-â…Ÿa)Â·a+1))Â·[aâ‰ 0]+[a=0])Â·((-[aâ‰¤0]Â·â…Ÿa+[-aâ‰¤0]Â·â…Ÿa)Â·[(-1+y)Â·â…Ÿa+-1â‰¤0]Â·[(-y+1)Â·â…Ÿaâ‰¤0]Â·[aâ‰ 0]+[a=0]Â·Î´(0)[-y+1])Â·(([((1+â…Ÿa)Â·a+-1)Â·â…Ÿaâ‰ 0]Â·[(-1+-â…Ÿa)Â·a+1â‰¤0]Â·[-â…Ÿaâ‰¤0]+[((1+â…Ÿa)Â·a+-1)Â·â…Ÿaâ‰ 0]Â·[(1+â…Ÿa)Â·a+-1â‰¤0]Â·[â…Ÿaâ‰¤0])Â·[aâ‰ 0]+[a=0])
}
+/
/+
def main(i){
	data := [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];
	return exp(data[i]);
}
+/
/+
def main(x){
	return exp((x==0)+(x==1));
}
+/
/+
def main(){
	x := 0;
	n := 5;
	for i in [0..n){
		x = laplace(x,1);
		if x>1/2{
			x-=1/2;
		}
	}
	return x;
}
+/
/+def main(a,b){
	//return gauss(0,1)/gauss(0,1);
	return a/b;
}
+/
/+import test2;

def main(){
	return foo();
}+/

/+def main(){
	//return flip(1/4);
	//return uniformInt(1,3);
	//return categorical([1/2,1/3,1/6]);
	//return binomial(2,1/2);
	//return infer(()=>1);
	//observe(flip(1/2));
	//return expectation(Marginal(uniform(0,1)));
	//x := uniformInt(-1,abs(2));
	//return abs(x);
	//x := flip;
	//return infer(()=>x(1/2));
	//return sample(infer(()=>1));
	//return Ï€;
	k := if flip(1/2) { infer } else { [b](f:ğŸ™â†’b) â‡’ Dirac(f()) };
	//return (()=>sample(k(()=>flip(1/2))))();
	return k(()=>flip(1/2));
}
+/


/+
eps := 0.01;

def variance(d: Distribution[â„]){
	return Expectation(sample(d)^2)-Expectation(sample(d))^2;
}

def main(a,b){
	assert(a>0&&b>0);
	//x := expectation(Beta(a,b)); // a/(a+b).
	//y := variance(Beta(a,b)); 
	//return y;
	x:=beta(a,b);
	observe(flip(x^(1/2)));
	observe(!flip(x^(1/2)));
	return x;
}
+/

/+
def id[a](b:*)(x:a,y:b) â‡’ x;

def main(){
	f := id;
	f = 2;
}
+/
/+
def main(){
	assert(flip(1/2));
	return 1;
}
+/
/*def main(){
	x := uniform(0,1);
	y := Marginal(x);
	return (x,sample(y));
}*/
/+
def main(){
	y := infer((){
		return uniform(0,1);
	});
	x := sample(y);
	return (x,sample(y));
}
+/
/*def main(){
	return sample(Flip(1/2));
}*/

/+
def main(){
	return flip(1/2);
}
+/
/+
def main(){
	x := flip(1/10000);
	observe(x);
	return Expectation(1);
}
+/

/+def foo(){
	return 0;
}

def main(){
	//y := uniformInt(0,x);
	//return Expectation(y);
	//y := ?x;
	return foo();
}
+/
/+
def main(){
	for i in [0..3){
		if flip(1/2){ return 0; }
	}
	return 1;
}
+/
/+
def main(){
	//x := gauss(0,1);
	//observe(x>=1);
	//y := gauss(0,1);
	//observe(x+2*y<=10);
	//return x+y;
	//return gauss(x,1);
	return x;
}
+/

/+
def main(){
	//return [flip(1/2), flip(1/3)];
	r := 0;
	for i in [0..100){
		r += flip(1/2);
	}
	return r;
}
+/
/+
def main(){
	//p := flip(1/2);
	//q := flip(1/2);
	return sin(2)^2+cos(2)^2;
}
+/
/+
def main(){
	x := uniform(-10,10);
	//return (x^2,x^3);
	return x^3;
}
+/
/+def mains(){
	return log(uniform(0,1)+exp(uniform(0,1)));
}+/


/+
def main(){
	//return gauss(0,1)^2;
	return uniform(0,1)^(1/2);
}
+/
/+
def main(){
	(x,y) := (0,1);
	(x,y) = (y,x);
	return (x,y);
}
+/
/+
n:=8;
def sum(a: â„[]){
	r := 0;
	for i in [0..a.length){
		r+=a[i];
	}
	return r;
}
def main(){
	a:=array(n,0);
	for i in [0..n){
		a[i] = flip(1/2);
	}
	return sum(a);
}
+/

/+
def main(){
	x := gauss(0,1);
	return x;
}
+/
/+
def main(N){
    if N-1 == 0{ return 1; }
    return (-N^3-N+2*N^2)/(N-1)==(1-N)*N
}
+/
/+def main(N){
    x := uniform(0,N-1);
    y := uniform(x,N);
    return y;
}
+/
/+
def main(){
	//return exp(uniform(0,1));
	return uniform(0,1)*uniform(0,1);
}
+/
/+
def main(){
	x := uniform(0,1);
	//return exp(x^2);
	return 2^x;
}
+/
/+def main(){
	return beta(0,0);
}+/

/+
def crash():â„{
	assert(0);
}
def fail():â„{
	observe(0);
}

def mains(){
	return fail()+crash();
}
+/
/+
def main(){
	p := uniform(0,1);
	observe(binomial(10, p)==6);
	return p;
}
+/
/+
def binomial(n,p){
	r := 0;
	for i in [0..n){
		r+=flip(p);
	}
	return r;
}
def main(){
	r := binomial(10,1/3);
	return r; // expected: 1/59049Â·Î´(0)[-r+10]+1024/59049Â·Î´(0)[r]+1120/19683Â·Î´(0)[-r+6]+1280/6561Â·Î´(0)[-r+2]+20/59049Â·Î´(0)[-r+9]+20/6561Â·Î´(0)[-r+8]+320/19683Â·Î´(0)[-r+7]+4480/19683Â·Î´(0)[-r+4]+5120/19683Â·Î´(0)[-r+3]+5120/59049Â·Î´(0)[-r+1]+896/6561Â·Î´(0)[-r+5]
}
+/
/+
def const[a](x:a)[b](y:b)=>x;

def main(){
	return const[R](3)[R x R x R](1,2,3);
}+/
/+
def id[a](x:a) => x;

def main(){
    return (id(2), id(id)(1,2));
}
+/

/+def main(){
	//x := sampleFrom("(x)=>2*x");
	//return Marginal(x);
	//x := uniformInt(0,1);
	//return (x,x);
	e := 0;
	e |= +2;
}+/


/+
def rec(){
	if flip(1/2){
		return 2;
	}else{
		return rec();
	}
}

def main(){
	
}
+/
/+
def observerModel () {
	p := uniform (0 ,1) ;
	coinSpinner := binomial(20, p) ;
	observe(coinSpinner == 15) ;
	return p ;// posterior beliefs
	// return Bernoulli(p) ;// bet on next spin
	// return Binomial(10,p) ;// next 10 spins
}
def main () {
	return observerModel();
}
+/
/+
dat Cell[a,b]{
	/*X[a](x:a): Cell[a];
	Y: Cell[â„];
	Z;*/
}

def main(){
	//return errorPr(infer((){assert(flip(2/3));}));
	x := Bernoulli(1/2);
	def foo()=>x;
	return foo();
}
+/
/+
def then[a,b](f: aâ†’ b)(d: Distribution[a])=>infer(()=>f(sample(d)));
def expectationOf[a](d: Distribution[a],f: aâ†’ â„)=>expectation(then(f)(d));

def main(){
	return expectationOf(Flip(1/2), (x)=>2*x);
	//return errorPr(infer((){ assert(flip(1/3)); }));
	//return expectation(infer(()=>flip(1/2)));
	//return expectation;
	//return sample(Flip(1/2));
	//x := then((x)=>x)(infer(()=>flip(1/3)));
	//return sample(x);
	//return x;
	//return then((x)=>x);
	//x = 3;
}
+/
/+def main(){
	return Expectation(poisson(0.00001));
}+/

/+def main(){
	p := beta(0,0);
	observe(flip(p));
	return p;
}
+/
/+
def model(){
	x := flip(0.5);
	y := if x {
		gauss(0,1);
	} else {
		uniform(0,1);
	};
	return (y,x)
}

def main(){
	(y,x) := model();
	//cobserve(y,0.3);
	return (y,x);
}
+/

/+
def foo(x){
	y := x;
	if y<0 { y = 0; }
	if y>1 { y = 1; }
	return (1,(flip(1/2),flip(1/3)),flip(y));
}
def main()=>foo(1/4);
+/
/+
def main(x){
	return 2*x;
}
+/
/+
def main(){
	p := flip(0.4);
	return p;
}
+/

/+def main(){
	/+x := array(1000,4);
	x[0] = uniform(0,1);
return x[0];+/
	/+x := set();
	for i in [0..50){
		x.add(i);
	}
return x.contains(uniform(0,100));+/
	/*{a: x, b: y}
	a := [0,1,0,1,1,0];
	return a[uniform(0,a.length-1)];*/	
}+/

/+
def main(){
	return infer;
}
+/
/+def main(a:â„Ã—â„){
	return uniform(a);
}
+/
/+
def main(){
	return uniform(0,1)^2;
}
+/


/+
def foo(x){
	if x<=0 { return 0; }
	return bar(x-1);
}
def bar(x)=>foo(x);

def main(){
	return foo(2);
}
+/

/+def id[a:*]=>(x:a)=>x;

def main(){
	/*x := id(1);
	y := id(1,2);
	z := id(1,2,3);
	
	for i in [0..10){
		x+=1;
	}
	//return (x,y,z);
	return id[âˆ[a:*].aâ†’a](id)[â„](3);*/
	x := uniform(0,1);
	y := uniform(0,1);
	return x+y+uniform(0,1);
}
+/



/+def main(x){
	//x := (a):â„{ return x(a); } // TODO!
	x:â„ := 3; // TODO!
}
+/

/+
def id[a](x:a)=>x;

def main(){
	return id(id)([1,2,3])[0];
}
+/


/+
def test(){
	arr := array(29,0);
	for i in [0..3){ arr[i]=1; }
	i := uniformInt(0,arr.length-1);
	hop := uniformInt(1,arr.length-1);
	for k in [0..arr.length){
		if arr[i]{
			return i;
		}
		i = (i+hop)%arr.length;
	}
	return -1;
}

def main(){
	return test();
}
+/
/+
def main(){
	x := flip(1/2);
	return (y)=>x;
}
+/

/+
def base(p):â„{
	assert(0);
}
def geom(g: â„ â†’ â„)(p: â„){
	if flip(p){
		return 1+g(p);
	}
	return 0;
}

def main(){
	g := base;
	for i in [0..20){
		g = geom(g);
	}
	return g(0.5);
}
+/
/+
def main(){
	f := (x)=>x;
	g := (x)=>2*x;
	h := if flip(1/2) { f } else { g };
	return h(uniform(0,1));
}
+/

/+def main(){
	x := uniform(0,1);	
	y := uniform(0,1);
	z := uniform(0,1);
	return x+y+z;
}+/
/+
def main(){
	p := uniform(0,1);
	observe(bernoulli(p)==1);
	observe(bernoulli(p)==0);
	observe(bernoulli(p)==0);
	observe(bernoulli(p)==0);
	observe(bernoulli(p)==0);
	observe(bernoulli(p)==0);
	observe(bernoulli(p)==0);
	observe(bernoulli(p)==0);
	observe(bernoulli(p)==0);	
	return p;
}
+/
/+
def main(f: â„ â†’ â„, g: â„ â†’ â„,x){
	return f(g(x));
}
+/


/+

a := 0, b := 1; // TODO: chars and strings.
bagel := 0, cookie := 1, nothing := 2, state := 3;

def haveCookie(obj) â‡’ obj==cookie;

def dirichlet(Î±: â„[]){ // TODO: add dirichlet distribution
	assert(Î±.length==2&&Î±[0]==2&&Î±[1]==1);
	return SampleFrom("(r)=>âˆ«da âˆ«db Î´_r[[i â†¦ [i=0]Â·a+[i=1]Â·b] (2)]Â·aÂ·[0â‰¤a]Â·[aâ‰¤1]Â·Î´(0)[a+b-1]"):â„[];
}

def main(){
	def actionPrior(){
		// return if flip(0.7) { ['a'] } else { ['a'] ~ actionPrior() } // TODO: recursion
		if flip(0.7){ return [a]; }
		if flip(0.7){ return [a,a]; }
		observe(0);
	}
	def chooseAction(goalSatisfied: â„ â†’ â„, transition: â„Ã—â„[] â†’ â„, state)=>
		infer((){
			action := actionPrior();
			observe(goalSatisfied(transition(state, action)));
			return action;
		});
	f := (){
		outcomeProbs := [dirichlet([2,1]),dirichlet([2,1])];
		def buttonsToOutcomeProbs(buttons: â„[]){ // TODO: mem/random functions
			assert(buttons.length==1||buttons.length==2&&buttons[0]==a);
			if(buttons.length==2){ assert(buttons[1]==a); }
			return outcomeProbs[buttons.length-1];
		}
		def vendingMachine(state,action: â„[])=>
			[bagel,cookie][categorical(buttonsToOutcomeProbs(action))];
		goal := [bagel,cookie][categorical([0.5,0.5])];
		def goalSatisfied(outcome) => outcome == goal;
		chosenAction := sample(chooseAction(goalSatisfied, vendingMachine, state));
		observe(goal == cookie && chosenAction.length==2 && chosenAction[0]==a && chosenAction[1]==a);
		return (buttonsToOutcomeProbs([a])[1],buttonsToOutcomeProbs([a,a])[1]);
	};
	//goalPosterior := infer(f);
	//return sample(goalPosterior); // expected: TODO: solve integrals (need to integrate rational functions)
	return f();
}
+/


/+
def main(){
	f := (x)=>flip(x);
	return expectation(infer(()=>f(1/2)));
}
+/
/+
def main(){
    x := gauss(0,1);
    assert(x<0); // fails with probability 1/2
}+/
/+
/+
def PrAgivenB[a](d: Distribution[a], A: aâ†’â„, B: aâ†’ â„){
	return expectation(infer((){
		x := sample(d);
		return A(x)&&B(x);
	}))/
		expectation(infer((){
			x := sample(d);
			return B(x)!=0;
		}));
}
+/
def PrAgivenB[a](d: Distribution[a], A: aâ†’â„, B: aâ†’ â„){
	return expectation(infer((){
		x := sample(d);
		observe(B(x));
		return A(x)!=0;
	}));
}

def main(X){
	joint := infer((){
		x := uniform(0,1);
		y := x^2+uniform(0,1);
		return (x,y);
	});
	// Pr(x<0.5|y>0.5):
	return PrAgivenB(joint,(x,y)=>x<X,(x,y)=>y>0.5);
}
+/
/+
n := 3;

def idPerm(k: â„){
	assert(k==n);
	r := array(n,0);
	for i in [0..n){ r[i]=i; }
	return r;
}

def bubbleSort(cmp: â„[][]){
	r := idPerm(n);
	for i in [0..n){
		for j in [0..n-1){
			if cmp[r[j+1]][r[j]]{
				t := r[j+1];
				r[j+1] = r[j];
				r[j] = t;
			}
		}
	}
	return r;
}
def randPerm(k: â„){
	assert(n == k);
	r := array(n,0);
	for i in [0..n){ r[i] = i; }
	for i in [0..n){
		j := uniformInt(i,n-1);
		t := r[j];
		r[j] = r[i];
		r[i] = t;
	}
	return r;
}
def reorderCmp(p:â„[])(cmp: â„[][]){
	r := array(n,array(n,0));
	for i in [0..n){
		for j in [0..n){
			r[p[i]][p[j]]=cmp[i][j];
		}
	}
	return r;
}
def shuffleCmp(cmp: â„[][])=>reorderCmp(randPerm(n))(cmp);

def noise(p: â„)(cmp: â„[][]){
	r := cmp;
	for i in [0..n){
		for j in [i+1..n){
			if flip(p){
				r[i][j]=!r[i][j];
				r[j][i]=!r[j][i];
			}
		}
	}
	return r;
	if flip(p){
		t := r[0][1];
		r[0][1] = r[1][0];
		r[1][0]=t;
	}
	return r;
}

def main(){
	arr := [1,2,0];
	cmp := array(n,array(n,0));
	for i in [0..n){
		for j in [0..n){
			cmp[i][j]=arr[i]<arr[j];
		}
	}
	cmp = shuffleCmp(cmp);
	cmpâ‚ := noise(0.01)(cmp);
	râ‚ := bubbleSort(cmpâ‚);
	cmpâ‚‚ := noise(0.01)(cmp);
	râ‚‚ := bubbleSort(cmpâ‚‚);
	return ((râ‚[0],râ‚f[1],râ‚[2]),(râ‚‚[0],râ‚‚[1],râ‚‚[2]));
}
+/

/+
def main(){
	d := Bernoulli(1/2);
	return sample(d);
}
+/

/+

def main(){
	dat Cell{
		x: â„;
		def Cell(x: â„){ this.x=x; }
	}
	c := Cell(if flip(1/2) { uniform(0,1) } else { 1/2 });
	return (c.x,c.x!=1/2);
}
+/

/+
def main(){
	def f() { return bernoulli(1/2);}
	x := infer(f);
	return x;
}
+/
/+
def test(d: Distribution[â„]){
	return sample(d);
}
+/

/+
def main(){
	return uniformInt(1,10);
}
+/
/+
def call(f: â„â†’ â„){
	x := f(0);
	x = f(x);
	x = f(x);
	x = f(x);
	x = f(x);
	x = f(x);
	x = f(x);
	x = f(x);
	x = f(x);
	x = f(x);
	return x;
}+/
/+
def main(){
	return call((x){ assert(flip(1/2)); return x+1; });
}
+/

/+def main(x){
	k := SampleFrom("(k;x)=>Î´_k[âˆ«dy [xÂ²+yÂ²â‰¤1]]",x);
	return k;
}
+/


/+
def test(d: â„,f:(ğŸ™â†’â„)â†’â„,g: â„â†’â„,h: â„â†’â„,eq: â„Ã—â„â†’â„){
	return h(f((){
		x := g(d);
		p := h(f((){ y:=g(d); return eq(x,y);}));
		return log(1/p)/log(2);
	}));
}
+/
/+
def logâ‚‚(x)=>log(x)/log(2);


//def entropy[a](eq: aÃ—a â†’ â„, d: Distribution[a]){ // TODO: polymporphic entropy function, typeclasses
def entropy(d: Distribution[â„]){
	return expectation(infer((){
		x := sample(d);
		//p := expectation(then((y) â‡’ x==y)(d));
		p := expectation(infer((){ y:=sample(d); return x==y;}));
		return logâ‚‚(1/p);
	}));
}
+/
/+
def main(){
	return entropy(infer(()=>flip(1/2)+flip(1/2)+flip(1/2)));
}
+/
/+
def foo(d:Distribution[â„]){
	return sample(d);
}
+/

/+def main(){
	return expectation(then((x)=>x+1)(infer((){ assert(flip(1/2));return flip(1/2);})));
}+/

/+
def f(lambda:â„â†’â„){
	return 0||lambda(0);
}
+/
/+
def mains(){
	return f((x)=>x);
}
+/
/+
def all(arr:â„){
	lambda:=(x)=>x!=0;
	return f(lambda,arr);
}
+/
/+
def main(){
    a := [flip(1/2)];
    return all(a);
}
+/


/+
def apply2(f:â„â†’â„,x){
	return f(f(x+flip(1/2)));
}

def main(){
	return apply2((x)=>2*x,3);
}
+/

/+def id(x){
	assert(flip(1/2));
	return x;
}

def main(){
	f := id;
	//x := ((x)=>x)(3);
	return f(3);
	//return f(3);
	//return (x);
	//return f;
}
+/
/+
def foo(f:â„â†’ â„){
	g:=(x)=>x;
	for i in [0..1){
		g=(x)=>f(g(x));
	}
	return g;
}
+/
/+
def main(){
	return foo((x)=>2*x)(1);
}
+/

/+
def main(){
	x := (f:â„â†’â„)=>f(3);
	f := (x)=>x+1;
	return x(f);
}
+/

/+
def logâ‚‚(x)=>log(x)/log(2);

def S[a](d: Distribution[a], x: a, eq: aÃ—aâ†’ â„)â‡’
	logâ‚‚(1/expectation(infer(()â‡’ eq(sample(d),x))));

def H[a](d: Distribution[â„], eq: â„Ã—â„â†’ â„, /*S: *â†’ Distribution[â„]Ã—â„Ã—(â„Ã—â„â†’â„)â†’â„*/)â‡’
    expectation(infer(()â‡’ S[â„](d,sample(d),eq)));
+/


/+
def logâ‚‚(x)=>log(x)/log(2);

def S[a](d: Distribution[a], x: a, eq: aÃ—aâ†’ â„)â‡’
	logâ‚‚(1/expectation(infer(()â‡’ eq(sample(d),x))));

def H[a](d: Distribution[a], eq: aÃ—aâ†’ â„)â‡’
	expectation(infer(()â‡’ S(d,sample(d),eq)));
+/
/+
def test(d: â„,f:(ğŸ™â†’â„)â†’â„,g: â„â†’â„,h: â„â†’â„,eq: â„Ã—â„â†’â„){
	return h(f((){
		x := g(d);
		p := h(f((){ y:=g(d); return eq(x,y);}));
		return log(1/p)/log(2);
	}));
}
+/

/+
dat Foo{
	x: â„;
	def Foo(x: â„){
		this.x=x;
	}
	def bar(){
		return ()=>()=>x;
	}
}

def main(){
	return Foo(2).bar()()();
}
+/

/+
def test(d: Distribution[â„],x){
	p := expectation(infer[â„]((){
		x := sample(d);
		y := expectation(infer(()=>sample(d)==x));
		//assert(y!=0);
		return 1/y;
	}));
	return p;
}
+/
/+
def main(){
	//return sample(sample(sample(infer(()=>Dirac(infer(()=>Dirac(infer(()=>Dirac(infer)))))))));
	f:=[a](x:Distribution[Distribution[Distribution[a]]])=>sample(sample(sample(x)));
	return f(Dirac(Dirac(Dirac(3))));
}
+/
/+
def main(){
	(x,y) := (1,2);
	(x,y) = (y,x);
	return (x,y);
}
+/

/+
n := 1;

def quantify(cmp: â„[][],p: â„[]){
	r := 0;
	for i in [0..n){
		for j in [j+1..n){
			r += cmp[p[i]][p[j]]-cmp[p[j]][p[i]];
		}
	}
	return r;
}

def main(){
	return quantify([[0]],[0]);
}
+/

/+

def main(){
	x := [0,1];
	(x[0],x[1]) = (x[1],x[0]);
	return (x[0],x[1]);
}
+/
/+
def bar[a](d: a)â‡’ 0;
def foo[a,b](d:aÃ—b)â‡’ bar(d);
+/


/+
def main(){
	x := gauss(0,1);
	y := 2*x;
	z := x+gauss(0,1);
	return Expectation(z*z);
}

/*
123
246
369
*/
+/



/+def foo(){
	x := 3;
	def bar(){
		x += 1;
	}
	return bar();
}+/

/+
def id(x:â„){
	//y:=x;
	//x:=3;
	if(1){
		//x:=4;
		return ()=>x;
	}
	assert(0);
}

def main(){
	return id(3)();
}
+/

/+
x := â„;

def foo[a]{
	def bar[a]{
		x:=a;
		return [a:x]{
			a := *;
			return ((x:a){ return x }:aâ†’ a)
		}
	}
	return bar;
}

def main(){
	x := foo[*];
	x = 3;
}
+/
/+
def main(x){
    return x^2+x+1;
}
+/
/+
def main(x,y){
    return (x+1,y+2);
}
+/
/+
def mains(x){
	return flip(x);
}
+/
/+
def main(){
	f := ()=>flip(1/2);
	return infer(f);
}
+/
/+
def foo(f:â„â†’â„){
	return f(2);
}

def main(){
	return foo((x)=>x);
}
+/

/+
def main(){
	x := Categorical([1/2,1/2]);
	return (expectation(x));
}
+/

/+
def main(){
	x := ()=>2;
	f:= ()=>x();
	return f();
}
+/
/+
dat Foo{
	x: â„;
	this: â„;
	def Foo(x:â„){
		this.x=x;
	}
	def foo(){
		return x;
	}
}


def mains(){
	/*x := 3;
	def foo(y,z){
		return y+x+z;
	}
	f := foo;
return f(2,3);*/
	f := Foo(3);
	x := f.foo;
	return x();
}
+/
/+
def foo(x){
	x = 3;
	return x;
}

def mains(){
	return foo(3);
}
+/

/+
def main(){
	z := 3;
	x := (y)=>y+z;
	return x;
}
+/
/+
def main(){
	x := array(floor(exponential(1)),0);
	return x[30];
}
+/
/+
dat Cell[a]{
	x: a;
	def Cell(x: a){
		this.x=x;
	}
}

def foo[a](x:a[])[b](y:b){
	return (x,y);
}

def main(){
	return foo([2])(4);
}
+/
/+
def foo(x){
	return 3*x;
}

def main(x){
	y := foo(x+3);
	return y;
}
+/

/+
def logâ‚‚(x)=>log(x)/log(2);
def entropy(d: Distribution[â„]){
	return expectation(infer((){
		x := sample(d);
		//p := expectation(then((y) â‡’ x==y)(d));
		p := expectation(infer((){ y:=sample(d); return x==y;}));
		//return logâ‚‚(1/p);
		//return logâ‚‚(1/p);
		return log(1/p);
	}));
}

def main(){
	return entropy(infer(()=>flip(1/2)+flip(1/2)+flip(1/2)));
}
+/

/+
def main(){
	a := array(100,0);
	for i in [0..a.length){
		a[i] = 1;
	}
	return a;
}
+/
/+
def main(){
	x := infer(()=>flip(1/2));
	return x;
}
+/



/+
def main(){
	return if flip(1/2) { â„ } else { â„[] };
	//return ([a](x:a)=>x)[â„];
}
+/


/+
def k(x:â„){
	return if x { â„ } else { â„[] };
}

def t(x:â„){
	return if x { 2 } else { [1,2,3] };
}

def main(){
	f := (x: k(flip(1/2)))=>x;
	return f(3);
}
+/

/+
dat Foo{
	x: Distribution[â„];
	def Foo(x: Distribution[â„]){
		this.x=x;
	}
}

def main(){
	return [Foo(Flip(1/2)),Foo(Flip(1/3))];
}
+/

/+
def main(){
	return ([]~[]).length+2;
}
+/
/+
def main(){
	//return 1/2;
	x := gauss(0,1128);
	return x;
}
+/
/+
def main(x){
	return (123/2)*x;
}
+/

/+def main(){
	return categorical(if flip(1/2){ [] } else {[1]});
}+/

/+def main(){
	return log(3287328787328723762376763287873287); // std.bigint bug!
}+/
/+
def main(){
	x:=[1,2,3];
	return ([]~x~[5,6])[4];
}
+/

/+
def main(){
	x := 0;
	x += uniformInt(0,1);
	x += uniformInt(0,1);
	x += uniformInt(0,1);
	return x;
}
+/

/+def main(){
	x := 10;
	while x>0 && flip(1/2) { x-=flip(1/2)+1; }
	return x;
}
+/


/+
def main(){
	x := 2;
	return x;
}
+/

/+
def pick[a](x: a[]){
	return x[uniformInt(0,x.length-1)];
}


def main(){
	return (pick([0,6]),pick([(1,2),(3,4)]));
}
+/


/+
def main(){
	return 1+?x+2;
}
+/
/+
def main(){
	k := infer(()=>flip(1/2));
	return k;
}
+/
/+
def main(){
	//(x,y):=SampleFrom("(x,y)=>x*Î´(0)[-x+1]Â·Î´(0)[y]Â·â…Ÿ2+Î´(0)[x]Â·Î´(0)[y-1]Â·â…Ÿ2");
	//return (y,x);
	assert(flip(1/2));
	return uniformInt(1,3);
}
+/

/+
def main(){
	x := 0;
	for i in [0..uniformInt(1,2)){
		//repeat uniformInt(1,2){
		x += i;
		x+=1;
	}
	return x;
}
+/

/+
def main(){
	def id[x:â„]=>x;
	return id[2];
}
+/
/+dat Tree{
	v: â„;
	t: Tree[];
	def Tree(t: Tree[]){
		this.t=t;
		this.v=1;
	}
	def sum():â„{
		s := v;
		for i in [0..t.length){
			s += t[i].sum();
		}
		return s;
	}
}

def main(){
	x := Tree([]:Tree[]);
	return x.sum();
}
+/
/+
def f(x){
	if x<=0{ return 0; }
	return 1+f(x-1);
}
def main(){
	return f(100);
}
+/

/+def program(input){
	assert(input != 2);
}

def main(){
	return argMax((input){
		d := infer(()=>program(input));
		return errorPr(d);
	});
	return (input);
}
+/



/+
def main(input){
	NN1 := readNN("NN1.net");
	NN2 := readNN("NN2.net");
	return argMax((input){
		x := NN1(input);
		y := NN2(input);
		return dist(x,y);
	});
}
+/

/+
def main(){
	return expectation(infer(()=>flip(1/3)));
}
+/

/+
def main(){
	return infer(()=>flip(1/3)+flip(1/3));
	//r := flip(1/2);
	//return infer((){assert(r);});
}
+/
/+
def main(){
	f := if flip(1/2) { flip } else { (x)=>2; };
	return f(1/2);
}
+/
/+
def main(){
	dat Foo{
		y: â„;
		def Foo(){
			this.y=2;
		}
	}
	return Foo();
}
+/

/+
def main(){
	x := 2;
	def foo(){ return x; }
	return foo();
}
+/

/+
def main(){
	return Ï€;
	a := flip(1/2);
	x := (y)=>y+a;
	return (if flip(1/2) { x } else { (k)=>(k-2) })(0);
}
+/
/+
def main(a,b,c,d,e,f){
	//return uniformInt(1,2);
	k := 0;
	for i in [0..10){
		k += i;
	}
	return (k,a,b,c,d,e,f);
}
+/
/+dat Packet{
	x: â„;
	def Packet(x){ this.x=x; }
}
dat Queue{
    data: (Packet Ã— â„)[];
    def Queue(){
        data = ([]:(Packet Ã— â„)[]);
    }
    def pushFront(x: Packet Ã— â„){
        data=[x]~data;
    }
    def pushBack(x: Packet Ã— â„){
        data=data~[x];
    }
    def takeFront(){
        r:=front();
        popFront();
        return r;
    }
    def takeBack(){
        r:=data[size()-1];
        data=data[0..size()-1];
        return r;
    }
    def size(){
        return data.length;
    }
    def front(){
        return data[0];
    }
    def popFront(){
        data=data[1..size()];
    }
}

def main(){
	q := Queue();
	q.pushFront(Packet(flip(1/2)),1);
	return q;
}
+/
/+
dat D{
	x: â„;
	def D(x){
		this.x = x;
	}
	def foo(y,z){
		x += y;
		return x;
	}
}

def main(){
	d := D(2);
	return d.foo(3,4);
	//return x.foo();
	//return x;
}
+/

/+def foo(x){
	return flip(x)+flip(1-x);
}

def main(){
	/*x := if 1 { 3 } else { assert(0); };
	if x {
		x *= 5;
	}else{
		x = 15;
	}
	// observe(x==15);
	return x;*/
	//r:=flip(1/2)+flip(1/2)+flip(1/2)+flip(1/2)+flip(1/2)+flip(1/2)+flip(1/2)+flip(1/2)+flip(1/2)+flip(1/2);
	//return foo(x);
	//assert(1);
	//assert(flip(1/2));
	//x := flip(1/2);
	//return foo(x);
	/*x := 1;
	r := foo(1/2);
	r+=foo(1/2);
	return (x,r);*/
	x := [];
	if flip(1/2) { x ~= [1]; }
	if flip(1/2) { x ~= [2]; }
	if flip(1/2) { x ~= [3]; }
	if flip(1/2) { x ~= [4]; }
	if flip(1/2) { x ~= [5]; }
	if flip(1/2) { x ~= [6]; }
	if flip(1/2) { x ~= [7]; }
	return x.length;
}
+/
