


// skipped

n := 3; // TODO: loops.

def logâ‚‚(x)=>log(x)/log(2);

def S[a](d: Distribution[a], x: a, eq: aÃ—aâ†’ â„)â‡’
	logâ‚‚(1/expectation(infer(()â‡’ eq(sample(d),x))));

def H[a](d: Distribution[a], eq: aÃ—aâ†’ â„)â‡’
	expectation(infer(()â‡’ S(d,sample(d),eq)));

def Ï€â‚[a,b](d: Distribution[aÃ—b])â‡’ infer(()=>sample(d)[0]);
def Ï€â‚‚[a,b](d: Distribution[aÃ—b])â‡’ infer(()=>sample(d)[1]);

def I[a,b](d: Distribution[aÃ—b], eqâ‚: aÃ—aâ†’ğ”¹, eqâ‚‚: bÃ—bâ†’ğ”¹)â‡’
	  H(Ï€â‚(d),eqâ‚) + H(Ï€â‚‚(d),eqâ‚‚) - H(d,eq_p(eqâ‚,eqâ‚‚));

def cH[a,b](d:Distribution[aÃ—b], eqâ‚: aÃ—aâ†’ğ”¹, eqâ‚‚: bÃ—bâ†’ğ”¹)â‡’ H(d,eq_p(eqâ‚,eqâ‚‚))-H(Ï€â‚‚(d),eqâ‚‚);


def â„‘[a](câ‚: Distribution[a], câ‚‚: Distribution[a], n: â„•, eq: aÃ—aâ†’ğ”¹){
	return logâ‚‚(n*expectation(infer((){
		sâ‚ := sample(câ‚);
		sâ‚‚ := sample(câ‚‚);
		return eq(sâ‚,sâ‚‚);
	})));
}

def genCap[a,b](A: aâ†’ Distribution[b], d: Distribution[a], noise: aâ†’ a, n: â„•, eq: bÃ—bâ†’ğ”¹){
	return expectation(infer((){ // "context-dependent" information
		x := sample(d);
		xâ‚ := noise(x);
		xâ‚‚ := noise(x);
		return â„‘(A(xâ‚),A(xâ‚‚),n,eq);
	}));
}

def genCapâ‚‚[a,b](f: aâ†’b, d: Distribution[a], noise: aâ†’a, eq: bÃ—bâ†’ğ”¹){
	return I(infer((){ // context-independent information: mutual information of outputs when applying different noise to the same input
		x := sample(d);
		xâ‚ := noise(x);
		xâ‚‚ := noise(x);
		return (f(xâ‚),f(xâ‚‚));
	}),eq,eq);
}


def genCapâ‚ƒ[a,b,t](A: aâ†’ b, x: a, T: Distribution[t], action: tâ†’ a â†’ a, noise: aâ†’ a, eqa: aÃ—aâ†’ğ”¹, eqt: tÃ—tâ†’ğ”¹, eqb: bÃ—bâ†’ğ”¹){ // may need to select T in a clever way.
	return I(infer((){
		xâ‚ := noise(x); // generate training data
		xâ‚‚ := noise(x); // generate validation data
		Ï„â‚› := sample(T); // sample transformation
		Ï„â‚›xâ‚‚ := action(Ï„â‚›)(noise(x)); // apply transformation to validation set
		câ‚ := A(xâ‚);
		cÏ„â‚‚ := A(Ï„â‚›xâ‚‚);
		return (Ï„â‚›,(xâ‚,câ‚,cÏ„â‚‚));
	}),eqt,eq_t(eqa,eqb,eqb));
	// want: I(Ï„,(xâ‚,câ‚,cÏ„â‚‚)) large.
}


// application to sorting

def idPerm(k: â„•){
	assert(k==n);
	r := array(n,0);
	for i in [0..n){ r[i]=i; }
	return r;
}

def factorial(k: â„){
	assert(k==n);
	r := 1;
	for i in [2..n]{ r *= i }
	return r;
}

def allPermutations(k: â„){
	assert(k==n);
	c := idPerm(n);
	r := [c];
	for x in [1..factorial(n)){
		a:=0, b:=1, f:=2, g:=1;
		for i in [3..n]{
			if x%f=0{
				g=f, f*=i;
				i+=1, b+=1;
			}
		}
		if b%2!=0{ a = (b*(x div g) div (b+1))%b; }
		// (c[a],c[b])=(c[b],c[a]); // TODO: allow!
		t := c[a];
		c[a] = c[b];
		c[b] = t;
		r ~= [c];
	}
	return r;
}

def quantify(cmp: ğ”¹[][],p: â„•[]){
	r := 0:â„¤;
	for i in [0..n){
		for j in [i+1..n){
			r += cmp[p[i]][p[j]]-cmp[p[j]][p[i]];
		}
	}
	return r;
}

def optimalSort(cmp: ğ”¹[][]){
	c := idPerm(n);
	k := quantify(cmp,c);
	r := c;
	bestk := k;
	for x in [1..factorial(n)){
		a:=0, b:=1, f:=2, g:=1;
		for i in [3..n]{
			if x%f==0{ // TODO: if !(x%f){
				g=f, f*=i;
				i+=1, b+=1;
			}
		}
		if b%2!=0{ a = (b*(x div g) div (b+1))%b; }
		// (c[a],c[b])=(c[b],c[a]); // TODO: allow!
		//sign := if c[a] < c[b] { 1 } else { -1 };
		t := c[a];
		c[a] = c[b];
		c[b] = t;
		k = quantify(cmp,c);
		if k>bestk{
			r=c;
			bestk=k;
		}
	}
	return r;
}

def bubbleSort(cmp: ğ”¹[][]){
	r := idPerm(n);
	for i in [0..n){
		for j in [0..n-1){
			if cmp[r[j+1]][r[j]]{
				t := r[j+1];
				r[j+1] = r[j];
				r[j] = t;
			}
		}
	}
	return r;
}

def selectionSort(cmp: ğ”¹[][]){
	r := idPerm(n);
	for i in [0..n){
		m := i;
		for j in [i+1..n){
			if cmp[r[j]][r[m]]{
				m=j;
			}
			t := r[m];
			r[m] = r[i];
			r[i] = t;
		}
	}
	return r;
}


def randPerm(k: â„){
	assert(n == k);
	r := array(n,0);
	for i in [0..n){ r[i] = i; }
	for i in [0..n){
		j := uniformInt(i,n-1);
		t := r[j];
		r[j] = r[i];
		r[i] = t;
	}
	return r;
}

def noise(p: â„)(cmp: ğ”¹[][]){
	r := cmp;
	for i in [0..n){
		for j in [i+1..n){
			if flip(p){
				r[i][j]=!r[i][j];
				r[j][i]=!r[j][i];
			}
		}
	}
	return r;
}

def eqâ„(x,y)=>x==y;
def eq_a[a](eq: aÃ—aâ†’ğ”¹)(x: a[],y: a[]){
	for i in [0..n){
		if !eq(x[i],y[i]){
			return false;
		}
	}
	return true;
}
def eq_p[a,b](eqa:aÃ—aâ†’ğ”¹,eqb:bÃ—bâ†’ğ”¹)(x:aÃ—b,y:aÃ—b)â‡’
	eqa(x[0],y[0])&&eqb(x[1],y[1]);

def eq_t[a,b,c](eqa: aÃ—aâ†’ğ”¹, eqb: bÃ—bâ†’ğ”¹, eqc: cÃ—câ†’ğ”¹)(x:aÃ—bÃ—c,y:aÃ—bÃ—c)â‡’
	eqa(x[0],y[0])&&eqb(x[1],y[1])&&eqc(x[2],y[2]);

def reorderCmp(p:â„•[])(cmp: ğ”¹[][]){
	r := array(n,array(n,0:ğ”¹));
	for i in [0..n){
		for j in [0..n){
			r[p[i]][p[j]]=cmp[i][j];
		}
	}
	return r;
}

def shuffleCmp(cmp: ğ”¹[][])=>reorderCmp(randPerm(n))(cmp);

def main(k){
	//arr := [3,2,0,1];
	//arr := randPerm(n);
	arr := [1,2,0];
	cmp := array(n,array(n,0:ğ”¹));
	for i in [0..n){
		for j in [0..n){
			cmp[i][j]=arr[i]<arr[j];
		}
	}
	//return noise(0.1)(cmp);
	//r := bubbleSort(cmp);
	//return (r[0],r[1],r[2],r[3]);
	input := infer(()=>shuffleCmp(cmp));
	//input := (SampleFrom("(input)=>Î´_input[Î»Î¾â‚. Î´_Î¾â‚[{.val â†¦ [Î¾â‚‚ â†¦ ((([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+1â‰ 0]+([Î¾â‚ƒ â†¦ [-Î¾â‚ƒ+2=0]Â·[Î¾â‚ƒâ‰ 0]] (3))Â·[-Î¾â‚‚+1=0])Â·[-Î¾â‚‚+2â‰ 0]+([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+2=0])Â·[Î¾â‚‚â‰ 0]+([Î¾â‚ƒ â†¦ ([-Î¾â‚ƒ+1=0]Â·[-Î¾â‚ƒ+2â‰ 0]+[-Î¾â‚ƒ+2=0])Â·[Î¾â‚ƒâ‰ 0]] (3))Â·[Î¾â‚‚=0]] (3),.tag â†¦ 1}]Â·â…Ÿ6+Î´_Î¾â‚[{.val â†¦ [Î¾â‚‚ â†¦ ((([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+1â‰ 0]+([Î¾â‚ƒ â†¦ [-Î¾â‚ƒ+2â‰ 0]Â·[Î¾â‚ƒ=0]] (3))Â·[-Î¾â‚‚+1=0])Â·[Î¾â‚‚â‰ 0]+([Î¾â‚ƒ â†¦ 0] (3))Â·[Î¾â‚‚=0])Â·[-Î¾â‚‚+2â‰ 0]+([Î¾â‚ƒ â†¦ ([-Î¾â‚ƒ+1=0]Â·[Î¾â‚ƒâ‰ 0]+[Î¾â‚ƒ=0])Â·[-Î¾â‚ƒ+2â‰ 0]] (3))Â·[-Î¾â‚‚+2=0]] (3),.tag â†¦ 1}]Â·â…Ÿ6+Î´_Î¾â‚[{.val â†¦ [Î¾â‚‚ â†¦ ((([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+2â‰ 0]+([Î¾â‚ƒ â†¦ [-Î¾â‚ƒ+1=0]Â·[Î¾â‚ƒâ‰ 0]] (3))Â·[-Î¾â‚‚+2=0])Â·[-Î¾â‚‚+1â‰ 0]+([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+1=0])Â·[Î¾â‚‚â‰ 0]+([Î¾â‚ƒ â†¦ ([-Î¾â‚ƒ+1=0]+[-Î¾â‚ƒ+1â‰ 0]Â·[-Î¾â‚ƒ+2=0])Â·[Î¾â‚ƒâ‰ 0]] (3))Â·[Î¾â‚‚=0]] (3),.tag â†¦ 1}]Â·â…Ÿ6+Î´_Î¾â‚[{.val â†¦ [Î¾â‚‚ â†¦ ((([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+2â‰ 0]+([Î¾â‚ƒ â†¦ [-Î¾â‚ƒ+1â‰ 0]Â·[Î¾â‚ƒ=0]] (3))Â·[-Î¾â‚‚+2=0])Â·[Î¾â‚‚â‰ 0]+([Î¾â‚ƒ â†¦ 0] (3))Â·[Î¾â‚‚=0])Â·[-Î¾â‚‚+1â‰ 0]+([Î¾â‚ƒ â†¦ ([-Î¾â‚ƒ+2=0]Â·[Î¾â‚ƒâ‰ 0]+[Î¾â‚ƒ=0])Â·[-Î¾â‚ƒ+1â‰ 0]] (3))Â·[-Î¾â‚‚+1=0]] (3),.tag â†¦ 1}]Â·â…Ÿ6+Î´_Î¾â‚[{.val â†¦ [Î¾â‚‚ â†¦ ((([Î¾â‚ƒ â†¦ 0] (3))Â·[Î¾â‚‚â‰ 0]+([Î¾â‚ƒ â†¦ [-Î¾â‚ƒ+1=0]Â·[-Î¾â‚ƒ+2â‰ 0]] (3))Â·[Î¾â‚‚=0])Â·[-Î¾â‚‚+1â‰ 0]+([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+1=0])Â·[-Î¾â‚‚+2â‰ 0]+([Î¾â‚ƒ â†¦ ([-Î¾â‚ƒ+1=0]+[-Î¾â‚ƒ+1â‰ 0]Â·[Î¾â‚ƒ=0])Â·[-Î¾â‚ƒ+2â‰ 0]] (3))Â·[-Î¾â‚‚+2=0]] (3),.tag â†¦ 1}]Â·â…Ÿ6+Î´_Î¾â‚[{.val â†¦ [Î¾â‚‚ â†¦ ((([Î¾â‚ƒ â†¦ 0] (3))Â·[Î¾â‚‚â‰ 0]+([Î¾â‚ƒ â†¦ [-Î¾â‚ƒ+1â‰ 0]Â·[-Î¾â‚ƒ+2=0]] (3))Â·[Î¾â‚‚=0])Â·[-Î¾â‚‚+2â‰ 0]+([Î¾â‚ƒ â†¦ 0] (3))Â·[-Î¾â‚‚+2=0])Â·[-Î¾â‚‚+1â‰ 0]+([Î¾â‚ƒ â†¦ ([-Î¾â‚ƒ+2=0]+[-Î¾â‚ƒ+2â‰ 0]Â·[Î¾â‚ƒ=0])Â·[-Î¾â‚ƒ+1â‰ 0]] (3))Â·[-Î¾â‚‚+1=0]] (3),.tag â†¦ 1}]Â·â…Ÿ6]"): Distribution[â„[][]]);
	error := noise(0.1);
	eq := eq_a(eqâ„);
	//T := infer(()=>randPerm(n));
	def genCapSort(sort: ğ”¹[][]â†’ â„•[]){
		return genCapâ‚‚(sort, input, error, eq);
		//return genCapâ‚ƒ(sort, cmp, T, reorderCmp, error, eq_a(eq),eq, eq);
	}
	//return genCapSort(bubbleSort);
	return (genCapSort(optimalSort),genCapSort(bubbleSort),genCapSort(selectionSort));
	/*k := eq_a(eqâ„)(optimalSort(cmp),bubbleSort(cmp));
	observe(!k);
	return (arr[0],arr[1],arr[2]);*/
	//r := optimalSort(cmp);
	//return (r[0],r[1],r[2]);
	//return (genCap(bubbleSort, input, noise(0.01), eq_a(eqâ„))/H(input)); // TODO: make this fast
	/*d := infer(()=>(uniformInt(0,1),uniformInt(0,2)));
	eqâ„â„ := eq_p(eqâ„,eqâ„);
	return I(d,eqâ„,eqâ„);*/
}
