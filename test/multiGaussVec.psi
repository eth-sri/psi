// skipped

// TODO: make this as fast as multiGauss
// TODO: add tensor types

k := 2; // global bound on the dimensions of all vectors and matrices

def multiGaussCholesky[n:â„•](Î¼: â„^n, D: (â„^n)^n){ // multivariate Gaussian based on cholesky decomposition of Î£.
	r := vector(n,0:â„);
	for i in [0..k){
		if i < n{
			r[i] = gauss(0,1);
		}
	}
	return avv(mmv(D,r),Î¼);
}

def multiGauss[n:â„•](Î¼: â„^n, Î£: (â„^n)^n){
	return multiGaussCholesky(Î¼,cholesky(Î£));
}

def main(){ // demo for multivariate Gaussian prior
	Î¼ := (0,0);
	Î£ := ((1,3/5),(3/5,1));
	//Î£ := [[1,2],[2,4]];
	//Î¼ := [0,0,0];
	//Î£ :=[[1,2,1],[2,4,2],[1,2,2]];
	r := multiGauss(Î¼,Î£); // using cholesky decomposition (somewhat slow)
	//r := sampleFrom("(x,y)=>5Â·e^(-25Â·xÂ²Â·â…Ÿ41+-25Â·yÂ²Â·â…Ÿ82+15Â·xÂ·yÂ·â…Ÿ41)Â·â…Ÿ2Â·â…ŸÏ€Â·â…Ÿâˆš4Ì…1Ì…"); // specifying PDF directly (very fast)
	return (r[0],r[1]); // expected: 5/8Â·e^(-25/32Â·râ‚€Â²+-25/32Â·râ‚Â²+15/16Â·râ‚€Â·râ‚)Â·â…ŸÏ€
	//return (r[0],r[1],r[2]);
	//D := cholesky(Î£);
	/+return (Expectation(r[0]*r[0]),Expectation(r[0]*r[1]),Expectation(r[0]*r[2]),
Expectation(r[1]*r[1]),Expectation(r[1]*r[2]),Expectation(r[2]*r[2]));+/
		//return ((D[0][0],D[1][0],D[1][1],D[2][0],D[2][1],D[2][2]),);
}


def mmv[n:â„•](A: (â„^n)^n, b: â„^n)pure{ // matrix-vector product
	return sampleFrom("(r;A,b,n)=>Î´([iâ†¦ âˆ‘_j[0â‰¤j]Â·[j<n] A@[i]@[j]Â·b@[j]] (n))[r]",A,b,n):â„^n; // performance hack
}

def avv[n:â„•](a: â„^n, b: â„^n)pure{ // vector addition
	return sampleFrom("(r;a,b,n)=>Î´([iâ†¦ a@[i]+b@[i]] (n))[r]",a,b,n):â„^n; // performance hack
}

def dot[n:â„•](a: â„^n, b: â„^n)pure{ // dot product for first m entries of vector
	return sampleFrom("(r;a,b,n)=>Î´(âˆ‘_i[0â‰¤i]Â·[i<n] a@[i]Â·b@[i])[r]",a,b,n); // performance hack
}

def cholesky[n:â„•](A: (â„^n)^n)pure{ // cholesky decomposition
	assert(sampleFrom("(r;A,n)=>Î´([âˆ‘_i[0â‰¤i]Â·[i<n]âˆ‘_j[0â‰¤j]Â·[j<n]Â·[A@[i]@[j]â‰ A@[j]@[i]]=0])[r]",A,n):ğ”¹);
	L := vector(n,vector(n,0:â„));
	for i in [0..k){
		if i < n {
			for j in [0..i+1){
				if j < n{
					t := dot(L[i][0..j],L[j][0..j]);
					if i == j {
						assert(A[i][j]>=t);
						L[i][j] = (A[i][j]-t)^(1/2)
					}else if L[j][j]!=0{
						L[i][j] = (A[i][j]-t)/L[j][j];
					}
				}
			}
		}
	}
	return L;
}
