// skipped

a := 0, b := 1; // TODO: chars and strings.
bagel := 0, cookie := 1, nothing := 2, state := 3;

def haveCookie(obj:â„•)â‡’obj==cookie;

def makeVendingMachine(aEffects: â„[],bEffects: â„[])(state:â„•,action:â„•)=>
	if action == a { [bagel,cookie][categorical(aEffects)] } else
	if action == b { [bagel,cookie][categorical(bEffects)] } else
                   { nothing };

def dirichlet(Î±: â„[]){ // TODO: add dirichlet distribution
	assert(Î±.length==2&&Î±[0]==1&&Î±[1]==1);
	p := uniform(0,1);
	return [p,1-p];
}

def main(){
	actionPrior := infer(()=>[a,b][categorical([0.5,0.5])]);
	def chooseAction(goalSatisfied: â„• â†’ ğ”¹, transition: â„•Ã—â„• â†’ â„•, state: â„•)=>
		infer((){
			action := sample(actionPrior);
			observe(goalSatisfied(transition(state, action)));
			return action;
		});
	
	aEffects := dirichlet([1,1]);
	bEffects := dirichlet([1,1]);
	vendingMachine := makeVendingMachine(aEffects,bEffects);
	goal := [bagel,cookie][categorical([0.5,0.5])];
	def goalSatisfied(outcome:â„•) => outcome==goal;
	observe(goal==cookie&&sample(chooseAction(goalSatisfied, vendingMachine, state))==b);
	//return bEffects[1]; // expected: (-2Â·log(bEffectsâ‚)+2Â·log(2))Â·[-1+bEffectsâ‚â‰¤0]Â·[-bEffectsâ‚â‰¤0]Â·[bEffectsâ‚â‰ 0]Â·bEffectsâ‚+2Â·[-1+bEffectsâ‚â‰¤0]Â·[-bEffectsâ‚â‰¤0]Â·bEffectsâ‚Â·log(1/2+1/2Â·bEffectsâ‚)
	return (aEffects[1],bEffects[1]); // expected: [-1+aEffectsâ‚â‰¤0]Â·[-1+bEffectsâ‚â‰¤0]Â·[-aEffectsâ‚â‰¤0]Â·[-bEffectsâ‚â‰¤0]Â·bEffectsâ‚Â·â…Ÿ(1/2Â·aEffectsâ‚+1/2Â·bEffectsâ‚)
}
